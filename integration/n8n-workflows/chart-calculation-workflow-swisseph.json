{
  "name": "Chart Calculation - Human Design (Swiss Ephemeris)",
  "nodes": [
    {
      "parameters": {
        "path": "chart-calculation",
        "options": {}
      },
      "id": "webhook-chart",
      "name": "Webhook - Chart Calculation",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "chart-calculation"
    },
    {
      "parameters": {
        "jsCode": "// Chart-Berechnung mit Swiss Ephemeris\n// Berechnet Human Design Chart-Daten basierend auf Geburtsdaten\n\nconst { birthDate, birthTime, birthPlace } = $input.item.json;\n\n// Swiss Ephemeris für Node.js\n// Installation: npm install swisseph\n// Oder nutze HTTP API: https://api.astro.com/swisseph\n\n// Parse Geburtsdaten\nconst [year, month, day] = birthDate.split('-').map(Number);\nconst [hours, minutes] = birthTime.split(':').map(Number);\\n\n// Berechne Julian Day\n// Swiss Ephemeris benötigt Julian Day für Berechnungen\nfunction calculateJulianDay(year, month, day, hours, minutes) {\n  const a = Math.floor((14 - month) / 12);\n  const y = year + 4800 - a;\n  const m = month + 12 * a - 3;\n  \n  const jdn = day + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;\n  \n  const jd = jdn + (hours - 12) / 24 + minutes / 1440;\n  return jd;\n}\n\nconst julianDay = calculateJulianDay(year, month, day, hours, minutes);\n\n// Swiss Ephemeris Planeten-Konstanten\nconst SE_SUN = 0;\nconst SE_MOON = 1;\nconst SE_MERCURY = 2;\nconst SE_VENUS = 3;\nconst SE_MARS = 4;\nconst SE_JUPITER = 5;\nconst SE_SATURN = 6;\nconst SE_URANUS = 7;\nconst SE_NEPTUNE = 8;\nconst SE_PLUTO = 9;\nconst SE_MEAN_NODE = 11; // North Node\nconst SE_TRUE_NODE = 10; // True Node\n\n// Konvertiere Planetenposition zu Human Design Gate\n// Human Design nutzt 64 Gates basierend auf I-Ching Hexagrammen\n// Jedes Gate entspricht einem Winkelbereich von 5.625° (360° / 64)\nfunction positionToGate(longitude) {\n  // Normalisiere auf 0-360°\n  let normalized = longitude % 360;\n  if (normalized < 0) normalized += 360;\n  \n  // Konvertiere zu Gate (1-64)\n  // Jedes Gate = 5.625° (360° / 64)\n  const gate = Math.floor(normalized / 5.625) + 1;\n  return gate > 64 ? 64 : gate;\n}\n\n// Konvertiere zu Linie (1-6)\n// Jedes Gate hat 6 Linien, jede Linie = 0.9375° (5.625° / 6)\nfunction positionToLine(longitude, gate) {\n  const normalized = longitude % 360;\n  if (normalized < 0) normalized += 360;\n  \n  const gateStart = (gate - 1) * 5.625;\n  const positionInGate = normalized - gateStart;\n  \n  const line = Math.floor(positionInGate / 0.9375) + 1;\n  return line > 6 ? 6 : line;\n}\n\n// TODO: Swiss Ephemeris API aufrufen\n// Option 1: Nutze swisseph Node.js Bibliothek (falls in n8n verfügbar)\n// Option 2: Nutze externe HTTP API\n// Option 3: Nutze Swiss Ephemeris Web Service\n\n// Beispiel: HTTP API Aufruf\nasync function calculatePlanets(julianDay) {\n  try {\n    // Option A: Nutze externe Swiss Ephemeris API\n    const response = await fetch(`https://api.astro.com/swisseph?jd=${julianDay}&planets=0,1,2,3,4,5,6,7,8,9,10,11`);\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    // Option B: Fallback - Nutze vereinfachte Berechnung\n    console.warn('Swiss Ephemeris API nicht verfügbar, nutze Fallback');\n    return calculatePlanetsFallback(julianDay);\n  }\n}\n\n// Fallback: Vereinfachte Berechnung (nur für Test)\nfunction calculatePlanetsFallback(julianDay) {\n  // Vereinfachte Berechnung basierend auf Julian Day\n  // In Produktion sollte echte Swiss Ephemeris API genutzt werden\n  \n  const planets = {};\n  const baseAngle = (julianDay % 360) * 2; // Vereinfachte Rotation\n  \n  planets.sun = { longitude: baseAngle, gate: positionToGate(baseAngle), line: positionToLine(baseAngle, positionToGate(baseAngle)) };\n  planets.moon = { longitude: (baseAngle + 30) % 360, gate: positionToGate((baseAngle + 30) % 360), line: positionToLine((baseAngle + 30) % 360, positionToGate((baseAngle + 30) % 360)) };\n  planets.mercury = { longitude: (baseAngle + 60) % 360, gate: positionToGate((baseAngle + 60) % 360), line: positionToLine((baseAngle + 60) % 360, positionToGate((baseAngle + 60) % 360)) };\n  planets.venus = { longitude: (baseAngle + 90) % 360, gate: positionToGate((baseAngle + 90) % 360), line: positionToLine((baseAngle + 90) % 360, positionToGate((baseAngle + 90) % 360)) };\n  planets.mars = { longitude: (baseAngle + 120) % 360, gate: positionToGate((baseAngle + 120) % 360), line: positionToLine((baseAngle + 120) % 360, positionToGate((baseAngle + 120) % 360)) };\n  planets.jupiter = { longitude: (baseAngle + 150) % 360, gate: positionToGate((baseAngle + 150) % 360), line: positionToLine((baseAngle + 150) % 360, positionToGate((baseAngle + 150) % 360)) };\n  planets.saturn = { longitude: (baseAngle + 180) % 360, gate: positionToGate((baseAngle + 180) % 360), line: positionToLine((baseAngle + 180) % 360, positionToGate((baseAngle + 180) % 360)) };\n  planets.uranus = { longitude: (baseAngle + 210) % 360, gate: positionToGate((baseAngle + 210) % 360), line: positionToLine((baseAngle + 210) % 360, positionToGate((baseAngle + 210) % 360)) };\n  planets.neptune = { longitude: (baseAngle + 240) % 360, gate: positionToGate((baseAngle + 240) % 360), line: positionToLine((baseAngle + 240) % 360, positionToGate((baseAngle + 240) % 360)) };\n  planets.pluto = { longitude: (baseAngle + 270) % 360, gate: positionToGate((baseAngle + 270) % 360), line: positionToLine((baseAngle + 270) % 360, positionToGate((baseAngle + 270) % 360)) };\n  planets.northNode = { longitude: (baseAngle + 300) % 360, gate: positionToGate((baseAngle + 300) % 360), line: positionToLine((baseAngle + 300) % 360, positionToGate((baseAngle + 300) % 360)) };\n  planets.southNode = { longitude: (baseAngle + 330) % 360, gate: positionToGate((baseAngle + 330) % 360), line: positionToLine((baseAngle + 330) % 360, positionToGate((baseAngle + 330) % 360)) };\n  \n  return planets;\n}\n\n// Berechne Chart-Daten\nconst planetsData = await calculatePlanets(julianDay);\n\n// Extrahiere Gates aus Planetenpositionen\nconst definedGates = [];\nconst planets = {};\n\nfor (const [planetName, planetData] of Object.entries(planetsData)) {\n  if (planetData.gate) {\n    definedGates.push(planetData.gate);\n    planets[planetName] = {\n      gate: planetData.gate,\n      line: planetData.line || 1,\n      longitude: planetData.longitude\n    };\n  }\n}\n\n// Entferne Duplikate\nconst uniqueGates = [...new Set(definedGates)];\n\n// Berechne Channels (basierend auf definierten Gates)\n// Channels verbinden zwei Gates (z.B. Gate 1-8 = Channel 1-8)\nconst channels = calculateChannels(uniqueGates);\n\n// Berechne Zentren (basierend auf definierten Gates)\nconst centers = calculateCenters(uniqueGates);\n\n// Berechne Typ, Profil, Autorität, Strategie\n// (Diese Berechnungen benötigen zusätzliche Logik)\nconst type = calculateType(centers);\nconst profile = calculateProfile(planetsData.sun, planetsData.earth);\nconst authority = calculateAuthority(centers);\nconst strategy = calculateStrategy(type);\n\n// Berechne Incarnation Cross\nconst incarnationCross = calculateIncarnationCross(planetsData.sun, planetsData.earth);\n\n// Zusammenfassung\nconst chartData = {\n  type,\n  profile,\n  authority,\n  strategy,\n  planets,\n  gates: {\n    defined: uniqueGates.sort((a, b) => a - b),\n    undefined: Array.from({length: 64}, (_, i) => i + 1).filter(g => !uniqueGates.includes(g)),\n    emphasis: uniqueGates.sort((a, b) => a - b)\n  },\n  channels,\n  centers,\n  incarnationCross,\n  birthDate,\n  birthTime,\n  birthPlace,\n  calculatedAt: new Date().toISOString()\n};\n\nreturn { json: chartData };\n\n// Hilfsfunktionen\nfunction calculateChannels(gates) {\n  // Channel-Mapping (welche Gates bilden Channels)\n  const channelMap = {\n    \"1-8\": [1, 8],\n    \"2-14\": [2, 14],\n    \"3-60\": [3, 60],\n    \"7-31\": [7, 31],\n    \"10-20\": [10, 20],\n    \"13-33\": [13, 33],\n    // ... alle 36 Channels\n  };\n  \n  const activeChannels = [];\n  \n  for (const [channelName, channelGates] of Object.entries(channelMap)) {\n    if (channelGates.every(gate => gates.includes(gate))) {\n      activeChannels.push(channelName);\n    }\n  }\n  \n  return {\n    active: activeChannels,\n    details: {}\n  };\n}\n\nfunction calculateCenters(gates) {\n  // Zentren-Mapping (welche Gates gehören zu welchem Zentrum)\n  const centerMap = {\n    head: [64, 61, 63],\n    ajna: [47, 24, 4],\n    throat: [23, 8, 20, 16, 35, 45, 12, 33, 31, 56, 62],\n    g: [1, 2, 7, 10, 13, 15, 25, 46],\n    heart: [21, 26, 40, 51],\n    solarPlexus: [6, 22, 36, 37, 49, 55, 30, 50, 58, 19, 60, 41],\n    sacral: [5, 14, 29, 9, 3, 42, 27, 34, 59],\n    spleen: [48, 57, 18, 28, 32, 44, 50, 52, 58],\n    root: [19, 39, 38, 41, 58, 60, 52, 53, 54]\n  };\n  \n  const definedCenters = [];\n  const undefinedCenters = [];\n  const details = {};\n  \n  for (const [centerName, centerGates] of Object.entries(centerMap)) {\n    const isDefined = centerGates.some(gate => gates.includes(gate));\n    \n    if (isDefined) {\n      definedCenters.push(centerName);\n    } else {\n      undefinedCenters.push(centerName);\n    }\n    \n    details[centerName] = { defined: isDefined, gates: centerGates.filter(g => gates.includes(g)) };\n  }\n  \n  return {\n    defined: definedCenters,\n    undefined: undefinedCenters,\n    details\n  };\n}\n\nfunction calculateType(centers) {\n  // Typ-Berechnung basierend auf definierten Zentren\n  const sacralDefined = centers.defined.includes('sacral');\n  const throatDefined = centers.defined.includes('throat');\n  const spleenDefined = centers.defined.includes('spleen');\n  \n  if (sacralDefined && throatDefined) return 'Generator';\n  if (throatDefined && !sacralDefined) return 'Manifestor';\n  if (!sacralDefined && !throatDefined && spleenDefined) return 'Projector';\n  if (!sacralDefined && !throatDefined && !spleenDefined) return 'Reflector';\n  \n  return null;\n}\n\nfunction calculateProfile(sun, earth) {\n  // Profil-Berechnung basierend auf Sonne und Erde\n  if (!sun || !earth) return null;\n  \n  const sunLine = sun.line || 1;\n  const earthLine = earth.line || 1;\n  \n  // Profil = Sonnen-Linie / Erd-Linie\n  return `${sunLine}/${earthLine}`;\n}\n\nfunction calculateAuthority(centers) {\n  // Autoritäts-Berechnung basierend auf definierten Zentren\n  if (centers.defined.includes('sacral')) return 'Sacral';\n  if (centers.defined.includes('solarPlexus')) return 'Emotional';\n  if (centers.defined.includes('spleen')) return 'Splenic';\n  if (centers.defined.includes('heart')) return 'Ego';\n  if (centers.defined.includes('g')) return 'Self';\n  if (centers.defined.includes('throat')) return 'Environmental';\n  \n  return null;\n}\n\nfunction calculateStrategy(type) {\n  // Strategie basierend auf Typ\n  const strategies = {\n    'Generator': 'Wait to respond',\n    'Manifestor': 'Inform',\n    'Projector': 'Wait for invitation',\n    'Reflector': 'Wait 28 days'\n  };\n  \n  return strategies[type] || null;\n}\n\nfunction calculateIncarnationCross(sun, earth) {\n  if (!sun || !earth) return null;\n  \n  // Incarnation Cross = Sonnen-Gate + Erd-Gate\n  // Vereinfachte Berechnung\n  return {\n    name: `Cross of ${sun.gate}-${earth.gate}`,\n    type: 'Right Angle', // Vereinfacht\n    sunGate: sun.gate,\n    sunLine: sun.line,\n    earthGate: earth.gate,\n    earthLine: earth.line,\n    meaning: null\n  };\n}"
      },
      "id": "calculate-chart",
      "name": "Calculate Chart (Swiss Ephemeris)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "respond-chart",
      "name": "Respond with Chart Data",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [650, 300]
    }
  ],
  "connections": {
    "Webhook - Chart Calculation": {
      "main": [
        [
          {
            "node": "Calculate Chart (Swiss Ephemeris)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Chart (Swiss Ephemeris)": {
      "main": [
        [
          {
            "node": "Respond with Chart Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-12-09T00:00:00.000Z",
  "versionId": "1"
}

