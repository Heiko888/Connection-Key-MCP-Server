{
  "name": "Reading Generation Workflow",
  "nodes": [
    {
      "parameters": {},
      "id": "webhook-reading",
      "name": "Reading Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "reading-generation",
      "settings": {
        "httpMethod": "POST",
        "path": "webhook/reading",
        "responseMode": "responseNode"
      }
    },
    {
      "parameters": {
        "jsCode": "// HARTE VALIDIERUNG: Alle PFLICHTFELDER prüfen\nconst body = $input.item.json.body || $input.item.json || {};\nconst errors = [];\n\n// PFLICHTFELDER\nconst requiredFields = {\n  readingId: body.readingId || $input.item.json.readingId,\n  name: body.name,\n  birthDate: body.birthDate,\n  birthTime: body.birthTime,\n  birthPlace: body.birthPlace,\n  readingType: body.readingType,\n  focus: body.focus\n};\n\n// Prüfe jedes Pflichtfeld\nObject.entries(requiredFields).forEach(([field, value]) => {\n  if (!value || (typeof value === 'string' && value.trim() === '')) {\n    errors.push(`${field} ist ein Pflichtfeld`);\n  }\n});\n\n// Format-Validierung\nif (requiredFields.birthDate && !/^\\d{4}-\\d{2}-\\d{2}$/.test(requiredFields.birthDate)) {\n  errors.push('birthDate muss im Format YYYY-MM-DD sein');\n}\n\nif (requiredFields.birthTime && !/^([0-1][0-9]|2[0-3]):[0-5][0-9]$/.test(requiredFields.birthTime)) {\n  errors.push('birthTime muss im Format HH:mm sein');\n}\n\n// HART ABBRECHEN bei Fehlern\nif (errors.length > 0) {\n  console.error('[n8n Workflow] VALIDIERUNGSFEHLER:', errors);\n  throw new Error(`VALIDIERUNGSFEHLER: ${errors.join('; ')}`);\n}\n\n// Payload normalisieren\nconst normalizedPayload = {\n  readingId: String(requiredFields.readingId).trim(),\n  name: String(requiredFields.name).trim(),\n  birthDate: String(requiredFields.birthDate).trim(),\n  birthTime: String(requiredFields.birthTime).trim(),\n  birthPlace: String(requiredFields.birthPlace).trim(),\n  readingType: String(requiredFields.readingType),\n  focus: String(requiredFields.focus).trim(),\n  userId: body.userId || null\n};\n\nconsole.log('[n8n Workflow] Payload validiert und normalisiert:', JSON.stringify(normalizedPayload, null, 2));\n\nreturn {\n  json: normalizedPayload\n};"
      },
      "id": "validate-payload",
      "name": "Validate Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300],
      "notes": "Harte Validierung aller PFLICHTFELDER - bricht bei Fehlern ab"
    },
    {
      "parameters": {
        "jsCode": "// Logging: Validierte Payload\nconst payload = $input.item.json;\n\nconsole.log(`[n8n Workflow] Reading Generation gestartet für readingId: ${payload.readingId}`);\nconsole.log(`[n8n Workflow] name: ${payload.name}`);\nconsole.log(`[n8n Workflow] readingType: ${payload.readingType}`);\nconsole.log(`[n8n Workflow] focus: ${payload.focus}`);\n\nreturn $input.all();"
      },
      "id": "log-start",
      "name": "Log Start",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 300],
      "notes": "Logging: Validierte Payload"
    },
    {
      "parameters": {
        "url": "={{ $env.READING_AGENT_URL || 'http://localhost:4000' }}/reading/generate",
        "authentication": "none",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "name",
              "value": "={{ $json.name }}"
            },
            {
              "name": "birthDate",
              "value": "={{ $json.birthDate }}"
            },
            {
              "name": "birthTime",
              "value": "={{ $json.birthTime }}"
            },
            {
              "name": "birthPlace",
              "value": "={{ $json.birthPlace }}"
            },
            {
              "name": "readingType",
              "value": "={{ $json.readingType }}"
            },
            {
              "name": "focus",
              "value": "={{ $json.focus }}"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "call-reading-agent",
      "name": "Call Reading Agent",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [850, 300],
      "notes": "Ruft Reading Agent (production/server.js) auf Port 4000 auf"
    },
    {
      "parameters": {
        "jsCode": "// VALIDIERUNG: Reading muss vorhanden sein\nconst input = $input.item.json;\nconst readingId = input.readingId;\nconst reading = input.reading || input.reading?.text || input.text || '';\nconst essence = input.essence || null; // Essence extrahieren\n\n// HART ABBRECHEN wenn Reading fehlt\nif (!reading || reading.trim() === '') {\n  console.error(`[n8n Workflow] FEHLER: Reading fehlt für readingId: ${readingId}`);\n  throw new Error('Reading wurde nicht generiert - Reading-Text fehlt');\n}\n\n// Payload-Daten aus vorherigen Nodes\nconst name = input.name || '';\nconst birthDate = input.birthDate || '';\nconst birthTime = input.birthTime || '';\nconst birthPlace = input.birthPlace || '';\nconst readingType = input.readingType || 'basic';\nconst focus = input.focus || '';\nconst userId = input.userId || null;\nconst chartData = input.chartData || {};\nconst tokens = input.tokens || 0;\n\nconsole.log(`[n8n Workflow] Reading generiert für readingId: ${readingId}`);\nconsole.log(`[n8n Workflow] Reading-Länge: ${reading.length} Zeichen`);\nconsole.log(`[n8n Workflow] Essence vorhanden: ${essence ? 'Ja (' + essence.length + ' Zeichen)' : 'Nein'}`);\nconsole.log(`[n8n Workflow] Tokens: ${tokens}`);\n\n// Result JSON für reading_jobs.result vorbereiten (jsonb)\nconst resultJson = {\n  reading: reading,\n  essence: essence, // Essence hinzufügen\n  name: name,\n  readingType: readingType,\n  focus: focus,\n  chartData: chartData,\n  tokens: tokens,\n  model: 'gpt-4',\n  timestamp: new Date().toISOString()\n};\n\n// Daten für readings Tabelle vorbereiten\nconst readingsData = {\n  readingId: readingId,\n  name: name,\n  birthDate: birthDate,\n  birthTime: birthTime,\n  birthPlace: birthPlace,\n  readingType: readingType,\n  focus: focus,\n  userId: userId,\n  reading: reading,\n  essence: essence, // Essence hinzufügen\n  chartData: chartData,\n  tokens: tokens\n};\n\nreturn {\n  json: {\n    readingId: readingId,\n    reading: reading,\n    essence: essence, // Essence weitergeben\n    readingType: readingType,\n    resultJson: resultJson,\n    readingsData: readingsData\n  }\n};"
      },
      "id": "prepare-result",
      "name": "Prepare Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 300],
      "notes": "Bereitet result JSON und readings Daten vor - bricht ab wenn Reading fehlt"
    },
    {
      "parameters": {
        "jsCode": "// Logging vor Update\nconst readingId = $input.item.json.readingId;\nconst resultJson = $input.item.json.resultJson;\n\nconsole.log(`[n8n Workflow] Update reading_jobs für readingId: ${readingId}`);\nconsole.log(`[n8n Workflow] Result JSON:`, JSON.stringify(resultJson));\n\nreturn $input.all();"
      },
      "id": "log-before-update",
      "name": "Log Before Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 300],
      "notes": "Logging vor reading_jobs Update"
    },
    {
      "parameters": {
        "operation": "insert",
        "table": "readings",
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "id": "={{ $json.readingId }}",
            "user_id": "={{ $json.readingsData.userId || null }}",
            "reading_type": "={{ $json.readingsData.readingType }}",
            "birth_date": "={{ $json.readingsData.birthDate }}",
            "birth_time": "={{ $json.readingsData.birthTime }}",
            "birth_place": "={{ $json.readingsData.birthPlace }}",
            "reading_text": "={{ $json.reading }}",
            "essence": "={{ $json.readingsData.essence || null }}",
            "chart_data": "={{ $json.readingsData.chartData || null }}",
            "metadata": "={{ { name: $json.readingsData.name, focus: $json.readingsData.focus, tokens: $json.readingsData.tokens || 0, model: 'gpt-4', timestamp: $now.toISO() } }}",
            "status": "completed"
          }
        }
      },
      "id": "save-reading",
      "name": "Save Reading",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [1250, 300],
      "credentials": {
        "supabaseApi": {
          "id": "supabase-credentials",
          "name": "Supabase API"
        }
      },
      "notes": "Speichert Reading in readings Tabelle - HART ABBRECHEN bei Fehler"
    },
    {
      "parameters": {
        "jsCode": "// VALIDIERUNG: Reading muss erfolgreich gespeichert worden sein\n// WICHTIG: readingId und alle Daten müssen durch die Kette gereicht werden\nconst input = $input.item.json;\nconst readingId = input.readingId || input.id;\n\nif (!readingId) {\n  console.error('[n8n Workflow] FEHLER: Reading wurde nicht gespeichert - keine ID zurückgegeben');\n  throw new Error('Reading wurde nicht gespeichert - INSERT fehlgeschlagen');\n}\n\nconsole.log(`[n8n Workflow] Reading erfolgreich gespeichert in readings Tabelle mit ID: ${readingId}`);\n\n// WICHTIG: Alle Daten durch die Kette reichen (readingsData wird für Notify Frontend benötigt)\nreturn $input.all().map(item => ({\n  json: {\n    ...item.json,\n    readingId: readingId, // Sicherstellen dass readingId vorhanden ist\n    id: input.id || readingId // Supabase gibt id zurück\n    // readingsData, reading, readingType bleiben erhalten\n  }\n}));"
      },
      "id": "validate-save",
      "name": "Validate Save",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 300],
      "notes": "Validiert dass Reading gespeichert wurde - bricht ab wenn nicht"
    },
    {
      "parameters": {
        "operation": "update",
        "table": "reading_jobs",
        "updateKey": "id",
        "updateKeyValue": "={{ $json.readingId || $json.id }}",
        "selectType": "manual",
        "selectConditions": {
          "conditions": [
            {
              "column": "id",
              "condition": "equal",
              "value": "={{ $json.readingId || $json.id }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "status": "completed",
            "progress": 100,
            "updated_at": "={{ $now.toISO() }}"
          }
        }
      },
      "id": "update-reading-job",
      "name": "Update Reading Job",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [1650, 300],
      "credentials": {
        "supabaseApi": {
          "id": "supabase-credentials",
          "name": "Supabase API"
        }
      },
      "notes": "Updated reading_jobs NUR wenn Reading erfolgreich gespeichert wurde"
    },
    {
      "parameters": {
        "jsCode": "// Logging nach Update\nconst readingId = $input.item.json.id || $input.item.json.readingId;\nconst status = $input.item.json.status;\n\nconsole.log(`[n8n Workflow] reading_jobs updated für readingId: ${readingId}`);\nconsole.log(`[n8n Workflow] Neuer Status: ${status}`);\n\nreturn $input.all();"
      },
      "id": "log-after-update",
      "name": "Log After Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1850, 300],
      "notes": "Logging nach reading_jobs Update"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.FRONTEND_URL || 'https://www.the-connection-key.de' }}/api/notifications/reading",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "readingId",
              "value": "={{ $json.readingId }}"
            },
            {
              "name": "userId",
              "value": "={{ $json.readingsData?.userId || $json.userId || null }}"
            },
            {
              "name": "readingType",
              "value": "={{ $json.readingType || $json.readingsData?.readingType }}"
            },
            {
              "name": "status",
              "value": "completed"
            },
            {
              "name": "timestamp",
              "value": "={{ $now }}"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "notify-frontend",
      "name": "Notify Frontend",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1050, 300],
      "notes": "Benachrichtigt Frontend über fertiges Reading"
    },
    {
      "parameters": {
        "jsCode": "// NORMALISIERE RESPONSE: Sicherstellen, dass nur EIN einziges JSON-Objekt zurückgegeben wird\n// Extrahiere das erste Item (falls mehrere vorhanden sind)\nconst inputItems = $input.all();\n\nif (inputItems.length === 0) {\n  console.error('[n8n Workflow] FEHLER: Keine Input-Items vorhanden');\n  throw new Error('Keine Daten für Response vorhanden');\n}\n\n// Nimm das erste Item (falls mehrere vorhanden sind)\nconst firstItem = inputItems[0].json;\n\n// Extrahiere readingId, status und readingText\nconst readingId = firstItem.readingId || firstItem.id || null;\nconst status = firstItem.status || 'completed';\nconst readingText = firstItem.reading || firstItem.reading_text || firstItem.readingsData?.reading || '';\n\n// VALIDIERUNG: Alle erforderlichen Felder müssen vorhanden sein\nif (!readingId) {\n  console.error('[n8n Workflow] FEHLER: readingId fehlt in Response');\n  throw new Error('readingId fehlt in Response-Daten');\n}\n\nif (!readingText || readingText.trim() === '') {\n  console.warn('[n8n Workflow] WARNUNG: readingText fehlt oder ist leer');\n}\n\nconsole.log(`[n8n Workflow] Response normalisiert für readingId: ${readingId}`);\nconsole.log(`[n8n Workflow] Status: ${status}`);\nconsole.log(`[n8n Workflow] Reading-Text Länge: ${readingText.length} Zeichen`);\n\n// Rückgabe: NUR ein einziges JSON-Objekt mit readingId, status und readingText\nreturn {\n  json: {\n    readingId: readingId,\n    status: status,\n    readingText: readingText\n  }\n};"
      },
      "id": "normalize-response",
      "name": "Normalize Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2050, 300],
      "notes": "Sichert dass nur EIN einziges JSON-Objekt (readingId, status, readingText) an Respond-Node übergeben wird"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { success: true, readingId: $json.readingId, status: $json.status, readingText: $json.readingText, message: 'Reading erfolgreich generiert und reading_jobs updated' } }}",
        "options": {}
      },
      "id": "webhook-response",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2250, 300]
    },
    {
      "parameters": {
        "jsCode": "// ERROR HANDLER: Fehler-Logging und Response\n// WICHTIG: readingId muss aus dem ursprünglichen Payload geholt werden\nconst input = $input.item.json;\nconst error = input.error || input.message || 'Unbekannter Fehler';\n\n// readingId kann aus verschiedenen Quellen kommen:\n// 1. Direkt im JSON (wenn von Validate Payload kommt)\n// 2. Aus body.readingId (wenn von Webhook kommt)\n// 3. Aus dem ursprünglichen Payload\nconst readingId = input.readingId || input.body?.readingId || input.json?.readingId || null;\n\nconsole.error(`[n8n Workflow] FEHLER: ${error} für readingId: ${readingId}`);\n\nreturn {\n  json: {\n    success: false,\n    error: error,\n    readingId: readingId,\n    message: `Workflow abgebrochen: ${error}`\n  }\n};"
      },
      "id": "error-handler",
      "name": "Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 500],
      "notes": "Error Handler für alle Fehler"
    },
    {
      "parameters": {
        "operation": "update",
        "table": "reading_jobs",
        "updateKey": "id",
        "updateKeyValue": "={{ $json.readingId || $json.id }}",
        "selectType": "manual",
        "selectConditions": {
          "conditions": [
            {
              "column": "id",
              "condition": "equal",
              "value": "={{ $json.readingId || $json.id }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "status": "failed",
            "error": "={{ $json.error || $json.message }}",
            "updated_at": "={{ $now.toISO() }}"
          }
        }
      },
      "id": "update-job-failed",
      "name": "Update Job Failed",
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [850, 500],
      "credentials": {
        "supabaseApi": {
          "id": "supabase-credentials",
          "name": "Supabase API"
        }
      },
      "notes": "Setzt reading_jobs auf 'failed' bei Fehlern"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { success: false, error: $json.error || $json.message, readingId: $json.readingId, message: 'Workflow abgebrochen' } }}",
        "options": {}
      },
      "id": "error-response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1050, 500],
      "notes": "Error Response an Webhook"
    }
  ],
  "connections": {
    "Reading Webhook": {
      "main": [
        [
          {
            "node": "Validate Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Payload": {
      "main": [
        [
          {
            "node": "Log Start",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Start": {
      "main": [
        [
          {
            "node": "Call Reading Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Reading Agent": {
      "main": [
        [
          {
            "node": "Prepare Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Result": {
      "main": [
        [
          {
            "node": "Save Reading",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Reading": {
      "main": [
        [
          {
            "node": "Validate Save",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Save": {
      "main": [
        [
          {
            "node": "Log Before Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Before Update": {
      "main": [
        [
          {
            "node": "Update Reading Job",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Reading Job": {
      "main": [
        [
          {
            "node": "Log After Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log After Update": {
      "main": [
        [
          {
            "node": "Notify Frontend",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Notify Frontend": {
      "main": [
        [
          {
            "node": "Normalize Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Response": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Payload": {
      "error": [
        [
          {
            "node": "Error Handler",
            "type": "error",
            "index": 0
          }
        ]
      ]
    },
    "Call Reading Agent": {
      "error": [
        [
          {
            "node": "Error Handler",
            "type": "error",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Result": {
      "error": [
        [
          {
            "node": "Error Handler",
            "type": "error",
            "index": 0
          }
        ]
      ]
    },
    "Save Reading": {
      "error": [
        [
          {
            "node": "Error Handler",
            "type": "error",
            "index": 0
          }
        ]
      ]
    },
    "Validate Save": {
      "error": [
        [
          {
            "node": "Error Handler",
            "type": "error",
            "index": 0
          }
        ]
      ]
    },
    "Update Reading Job": {
      "error": [
        [
          {
            "node": "Error Handler",
            "type": "error",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler": {
      "main": [
        [
          {
            "node": "Update Job Failed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Job Failed": {
      "main": [
        [
          {
            "node": "Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-12-13T18:00:00.000Z",
  "versionId": "1"
}
